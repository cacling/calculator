## 项目概述
开发一个计算器应用程序，实现两个数的加、减、乘、除运算，并提供undo和redo操作。

## 需求分析
1. 提供基本的计算器界面，允许用户选择数字、小数点、括号，选择加、减、乘、除运算运算符，提交后显示计算结果。
2. 用户能够选择撤销之前的操作并恢复之前的计算结果，即undo操作。
3. 用户能够重新执行已经被undo的操作，即redo操作。

## 项目架构
采用前后端分离架构，前端通过RESTful API调用后端接口，后端进行计算等操作后并返回结果给前端。

### 前端设计
#### 界面设计
- 界面包括 0-9数字、小数点、等于号、左右括号、重做、撤销按钮，显示计算公式区框、显示计算结果框。
- 错误提示。用户输入的不符合计算规则，或者已经没有可重做、撤销的操作，弹出提示框提示。
技术选型
##### 采用Vue3
Vue3是基于MVVM架构模式的前端JavaScript框架，。具有以下优点：
1. 适用于中小型应用：相比于React和Angular，入门门槛较低，可以快速上手。但对于大型应用来说，可能需要使用更加强大的框架，如Angular。
2. 双向数据绑定：相对JQuery等工具框架，Vue的双向数据绑定使得前端开发更加方便和高效，不需要手动操作DOM，可以直接对数据进行操作。且Vue采用了虚拟DOM技术和异步渲染等技术，有很好的性能和渲染速度。
3. 生态系统丰富：Vue有大量的第三方插件和工具，如vue-router、vuex、axios等，可以快速实现各种复杂的功能。本项目就引入了Axios插件，一个基于Promise的HTTP客户端，支持异步发送GET、POST等常见的HTTP请求。
4. 支持TypeScript：TypeScript 提供了强大的类型系统和类型检查，可以让代码更加健壮和可靠，减少因为类型错误而导致的 bug。通过类型注解可以清楚地知道每个变量的类型和作用，结合智能的代码提示和自动补全功能， 自动检测出不合法的代码，提高开发效率，提高代码可读性。

##### 采用Bulma
Bulma是一个基于Flexbox布局的轻量级CSS框架，提供了一组简洁、灵活的CSS类。具有以下优点：
1. 简单易用：语义化、模块化和响应式设计使其易于学习和使用。
2. 易于自定义：具有灵活的变量和可定制的样式，可以轻松地自定义UI风格。
3. 响应式设计：Flexbox布局便于自适应不同屏幕大小，能够自动适应移动设备、平板电脑和桌面端。
4. 非常轻量：的CSS文件非常小，仅有几十KB，不会增加网页的加载时间。
注：Bootstrap、Element UI、Ant Design Vue等都提供了丰富的UI组件和交互式操作，各有各优缺点，但学习成本相对较高，选择哪一个框架可取决于实际开发团队的偏好。

### 后端设计
#### 技术选型
##### 采用Spring Boot
1. 快速搭建：提供了一些开箱即用的配置，使得开发者可以快速地搭建一个完整的、可运行的应用程序。
2. 简化配置：大量采用约定优于配置的方式，简化了配置文件，降低了开发者的工作量。
3. 自动化配置：通过自动配置的方式，可以减少手动配置的工作量，并保证应用程序的稳定性和正确性。

##### 采用ANLTR4
1. 词法分析器和语法分析：是一款高效的解析器生成器，可以快速生成词法分析器和语法分析器，同时也可以生成抽象语法树，从而可以快速地解析输入。
2. 可维护性高：基于ANTLR4的语法规则，通过.g4配置文件，可定义计算公式的语法结构、语义规则和词法规则。各主流IDE中提供了ANTLR4的插件，帮助开发者定义语法规则和创建解析器，避免了手写解析器的繁琐过程。
3. 可扩展性高：支持语法扩展，可以轻松地扩展现有计算公式规则，实现更多的高级功能。例如：支持其它（例如“%”）等运算符号 ；支持平方根、倒数、余数、三角函数等函数。

#### 关键技术点
计算公式解释和处理逻辑
处理过程：语法规则定义 -> 词法分析 -> 语法分析 -> 语义分析
1. 语法规则定义：创建Calculator.g4，定义三个非终结符：expression、term和factor。expression表示一个完整的表达式，由一个或多个term和加号或减号组成。term表示一个项，由一个或多个factor和乘号或除号组成。factor表示一个因子，它可以是一个数字或一个括号内的表达式。
2. 词法分析：生成CalculatorParser.java，这是基于DFA的词法分析器，它通过预先定义的正则表达式来识别语言中的单词，生成词法符号（Token）序列。每个Token包含了它所属的类型、文本值以及所处的位置信息等信息。
3. 语法分析：生成CalculatorLexer.java，这是计算公式的语法分析器，采用了自顶向下的递归下降分析算法，它从文法规则的起始符号开始，递归地展开文法规则，并生成一棵语法树（Parse Tree）。在生成语法树的过程中，ANTLR4会自动处理语法规则的优先级和结合性等问题。
4. 语义分析：创建MyCalculatorVisitor.java，使用Visitor设计模式来实现语义分析。该类中定义了访问解析树节点的方法，对解析树进行深度优先遍历，并根据需要执行相应的语义操作。采用Visitor模式可以将遍历和操作解耦，从而使得操作可以独立于解析树的具体结构，可以更方便地处理复杂的语言结构和嵌套规则，因此代码的可维护性和可扩展性也更高。

#### undo和redo操作处理逻辑
需要创建两个栈，一个用来存储已经执行过的运算，另一个用来存储撤销过的运算。每次执行一个运算时，就把它压入第一个栈。每次撤销一个运算时，就把第一个栈的栈顶元素弹出，并压入第二个栈。每次恢复一个运算时，就把第二个栈的栈顶元素弹出，并压入第一个栈。
如果功能需求计算器应用程序重启后，仍然可以使用undo和redo操作，可以考虑选择适合的持久化方案，把操作数据存储在磁盘介质中，例如文件或数据库。

#### 业务响应码定义
后端接口定义了不同的响应码，标识不同的返回结果，前端根据响应码进行相应的处理。一般情况下，接口的响应码可以分为正常情况和异常情况的响应码。正常情况的响应码为 200，表示请求成功并返回相应的数据。对于异常情况，定义不同的响应码来表示不同的错误类型。

## 测试策略
### 单元测试
将对Calculator类进行单元测试，以确保其正确执行四则运算基本计算操作，并正确维护操作记录栈，确保其正确执行撤销和重做操作。测试包括正常输入、非法输入和异常情况等不同场景，以保证程序的稳定性和健壮性。
单元测试使用了Mockito框架来模拟依赖项和对象行为。@InjectMocks注解指示框架将CalculatorApplication实例注入到测试中，可以直接调用被测试的方法。在testCalc()测试中，检查当输入“`(3.2+0.8)*3+(3-1)`”时，calc()方法是否正确地返回了结果“14”。在testUndo()和testRedo()测试中，测试了undo()和redo()方法的行为，首先计算了两个不同的表达式，并调用undo()方法来撤销最后一次运算，然后调用redo()方法来恢复该运算。在每个测试中，检查结果是否符合预期值。

### 集成测试
Selenium可以控制Chrome、Safari、Edge等多种浏览器，模拟用户在前端界面上的操作，进行自动化集成测试，以确保前后端之间的协调和通信正常工作，并全面地测试计算器应用程序在各浏览器的兼容性。
注：运行程序前，需要先安装Selenium WebDriver(核心库，用于控制浏览器)和ChromeDriver(用于控制浏览器的驱动程序)。

## 项目目录结构
```
- src/main/java  //Java代码的主要源代码
  - CalculatorApplication.java // Spring Boot 主应用程序入口
  - com.example.calculator
    - controller  // 控制器层，处理用户请求
      - CalculatorController.java   
    - service  // 服务层，处理业务逻辑
      - CalculatorService.java  
      - antlr4
        - Calculator.g4  // ANTLR4 语法文件，定义计算器的语法规则
        - CalculatorParser.java  // 自动生成的语法解析器
        - CalculatorLexer.java  // 自动生成的词法解析器
    - model  // 模型层，存放数据模型
      - Operation.java
- src/main/resources
  - application.properties  // Spring Boot 配置文件
- src/test/java   // 测试用例的代码
  - com.example.calculator
    - CalculatorControllerTests.java  // 控制器测试用例
    - CalculatorSeleniumTest.java  // 使用 Selenium 进行的端到端测试
- frontend/src   // 前端JavaScript代码的主要源代码
  - App.vue  // Vue.js 主应用程序组件
  - components
    - Calculator.vue  // 计算器Vue.js组件
- pom.xml //Maven 配置文件
```

## 部署方案
该项目可采用Docker进行部署。将前端代码打包为一个Docker镜像，并将后端代码打包为另一个Docker镜像，并分别上传到 Docker Hub 或者私有仓库中，供后续部署使用。两个镜像在部署时分别运行在不同的容器中，并通过网络进行通信，在 后端Spring Boot 项目中，需要通过配置 CORS（跨域资源共享）策略来实现前端调用后端时的跨域访问。
### 后端项目
1. 使用 Maven 构建 Spring Boot 项目。在项目根目录下，运行以下命令：`mvn clean package`
2. 在项目根目录下，运行以下命令构建 Docker 镜像：
`docker build -t calculator-backend .`
3. 将 Spring Boot 项目打包成一个 Docker 镜像：`docker run -d -p 8080:8080 --name calculator calculator-backend`
### 前端项目
1. 在项目根目录下，运行以下命令构建 Docker 镜像：`docker build -t calculator-frontend .`
2. 将 Vue 项目打包成一个 Docker 镜像：`docker run -d -p 80:80 --name calculator calculator-frontend`
3. 在浏览器中访问 http://localhost 来 Vue 项目。